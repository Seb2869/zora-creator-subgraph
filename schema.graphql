type TransactionInfo @entity {
  id: ID!
  block: BigInt!
  timestamp: BigInt!
}

type SalesConfig @entity(immutable: true) {
  id: ID!

  publicSalePrice: BigInt!
  maxSalePurchasePerAddress: BigInt!
  publicSaleStart: BigInt!
  publicSaleEnd: BigInt!
  presaleStart: BigInt!
  presaleEnd: BigInt!
  presaleMerkleRoot: Bytes!

  drop: ERC721Drop!
}

type ContractConfig @entity {
  id: ID!

  metadataRenderer: Bytes!
  editionSize: BigInt!
  royaltyBPS: Int!
  fundsRecipient: Bytes!

  drop: ERC721Drop!
}

type ERC721Drop @entity {
  id: ID!

  created: TransactionInfo!

  creator: Bytes!
  address: Bytes!
  name: String!
  symbol: String!

  contractConfig: ContractConfig!
  salesConfigId: BigInt!

  salesConfig: SalesConfig!
  salesConfigHistory: [SalesConfig!]! @derivedFrom(field: "drop")

  sales: [NFTEditionSale!]! @derivedFrom(field: "drop")

  transfers: [NFTEditionTransfer!]! @derivedFrom(field: "drop")

  totalMinted: BigInt!
  maxSupply: BigInt!

  metadata: MetadataConnection!

  txn: TransactionInfo!
}

type MetadataConnection @entity {
  id: ID!
  renderer: Bytes!

  metadataDrop: MetadataDrop!
  # TODO(iain): Metadata history
  metadataEdition: MetadataEdition!
}

type MetadataDrop @entity {
  id: ID!

  baseURI: String!
  baseURIExtension: String!
  contractURI: String!
  provenanceHash: String!
}

type MetadataEdition @entity {
  id: ID!

  description: String!
  imageURI: String!
  animationURI: String!
}

type NFTEditionSale @entity {
  id: ID!
  pricePerToken: BigInt!
  priceTotal: BigInt!
  count: BigInt!
  purchaser: Bytes!
  firstPurchasedTokenId: Int!
  txn: TransactionInfo!
  drop: ERC721Drop!
}

type NFTEditionTransfer @entity {
  id: ID!

  tokenId: BigInt!
  to: Bytes! # from address for transfer
  from: Bytes! # to address for transfer
  txn: TransactionInfo!

  drop: ERC721Drop!
}