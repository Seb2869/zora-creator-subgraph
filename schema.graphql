type TransactionInfo @entity {
  id: ID!
  block: BigInt!
  timestamp: BigInt!
}

type SalesConfig @entity(immutable: true) {
  id: ID!

  publicSalePrice: BigInt!
  maxSalePurchasePerAddress: BigInt!
  publicSaleStart: BigInt!
  publicSaleEnd: BigInt!
  presaleStart: BigInt!
  presaleEnd: BigInt!
  presaleMerkleRoot: Bytes!

  drop: ERC721Drop!
}

type ContractConfig @entity {
  id: ID!

  metadataRenderer: Bytes!
  editionSize: BigInt!
  royaltyBPS: Int!
  fundsRecipient: Bytes!

  drop: ERC721Drop!
}

type ERC721Drop @entity {
  id: ID!

  created: TransactionInfo!
  createdAt: BigInt!
  
  version: BigInt!

  contractURI: String

  creator: Bytes!
  owner: Bytes!
  address: Bytes!
  network: String!
  name: String!
  symbol: String!

  contractConfig: ContractConfig!

  salesConfig: SalesConfig!

  salesConfigHistory: [SalesConfig!]! @derivedFrom(field: "drop")

  sales: [NFTEditionSale!]! @derivedFrom(field: "drop")
  transfers: [NFTEditionTransfer!]! @derivedFrom(field: "drop")

  editionMetadata: EditionMetadata @derivedFrom(field: "drop")
  dropMetadata: DropMetadata @derivedFrom(field: "drop")

  roles: [DropRole!]! @derivedFrom(field: "drop")

  totalMinted: BigInt!
  maxSupply: BigInt!

  rendererAddress: Bytes!

  txn: TransactionInfo!
}


type ZoraCreate721Factory @entity {
  id: ID!
  implementation: Bytes!
  version: BigInt!

  updatedAt: Int!
}

type ZoraCreate1155Factory @entity {
  id: ID!
  fixedPriceSaleStrategyAddress: Bytes!
  implementation: Bytes!
  merkleSaleStrategyAddress: Bytes!
  version: String!

  updatedAt: Int!
}

type ZoraCreateContract @entity {
  id: ID!
  name: String
  symbol: String
  contractURI: String #fix 
  contractStandard: String #fix
  metadata: MetadataInfo
  creator: String
  defaultAdmin: String

  updatedAt: Int # fix
}

type ZoraCreateToken @entity {
  id: ID!
  uri: String!
  rendererContract: String!
  contract: String!
  tokenId: Int
  metadata: MetadataInfo

  salesStrategies: [ERC1155SalesStrategyConfig!]

  updatedAt: Int!
}

type ERC1155SalesConfigFixedPriceSaleStrategy @entity {
  id: ID!

  saleStart: BigInt!
  saleEnd: BigInt!
  maxTokensPerTransaction: BigInt!
  maxTokensPerAddress: BigInt!
  pricePerToken: BigInt!
  fundsRecipient: Bytes!

  updatedAt: Int!
}

type ERC1155SalesConfigMerkleMinterStrategy @entity {
  id: ID!

  presaleStart: BigInt!
  presaleEnd: BigInt!
  fundsRecipient: Bytes!
  merkleRoot: Bytes!
  updatedAt: BigInt!
}

type ERC1155SalesStrategyConfig @entity {
  id: ID!
  presale: ERC1155SalesConfigMerkleMinterStrategy
  fixedPrice: ERC1155SalesConfigFixedPriceSaleStrategy
  type: String!
  updatedAt: Int!
}

type MetadataInfo @entity {
    id: ID!
    name: String!
    title: String!
    image: String!
    properties: String!
    rawJson: String!
		updatedAt: Int!
}

type ERC1155Creator @entity {
  id: ID!

  created: TransactionInfo!
  createdAt: BigInt!
}

type DropRole @entity {
  # user-role
  id: ID!
  account: Bytes!
  sender: Bytes!
  roleHash: Bytes!
  role: String!
  updated: BigInt!
  granted: Boolean!

  drop: ERC721Drop!
}

type DropRoleHistory @entity {
  # txn hash for granted role
  id: ID!
}

type NFTEditionSale @entity {
  id: ID!
  pricePerToken: BigInt!
  priceTotal: BigInt!
  count: BigInt!
  purchaser: Bytes!
  firstPurchasedTokenId: Int!
  txn: TransactionInfo!
  mintedAt: BigInt!

  drop: ERC721Drop!
}

type NFTEditionTransfer @entity {
  id: ID!

  tokenId: BigInt!
  to: Bytes!
  from: Bytes!
  txn: TransactionInfo!
  mintedAt: BigInt!

  drop: ERC721Drop!
}

type Upgrade @entity {
  id: ID!
}

type EditionMetadata @entity {
  id: ID!

  drop: ERC721Drop!
  description: String!
  contractURI: String
  imageURI: String!
  animationURI: String!
}

type DropMetadata @entity {
  id: ID!

  drop: ERC721Drop!
  base: String!
  extension: String!
  freezeAt: BigInt!
  contractURI: String!
}
